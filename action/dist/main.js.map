{
  "version": 3,
  "sources": ["../src/main.ts", "../src/constants.ts", "../src/inputs.ts", "../src/util.ts"],
  "sourcesContent": ["import * as core from \"@actions/core\";\nimport fs from \"node:fs/promises\";\nimport util from \"node:util\";\nimport { exec as execCb, spawn, spawnSync } from \"node:child_process\";\nimport path from \"node:path\";\nimport {\n  AGENT_LOG_FILENAME,\n  CONNECT_LOG_FILENAME,\n  TETRAGON_LOG_FILENAME,\n  BLOCK,\n  ALLOWED_DOMAINS_ONLY,\n  AGENT_INSTALL_PATH,\n  TETRAGON_EVENTS_LOG_PATH,\n  AGENT_READY_PATH,\n} from \"./constants\";\nimport { parseInputs, EgressPolicy, DnsPolicy } from \"./inputs\";\nimport { waitForFile } from \"./util\";\n\nconst exec = util.promisify(execCb);\n\nfunction installPackages() {\n  console.log(\"Installing packages\");\n\n  const { status } = spawnSync(\n    \"sudo\",\n    [\"apt-get\", \"install\", \"-y\", \"libnetfilter-queue-dev\", \"nftables\"],\n    { stdio: \"inherit\" }\n  );\n\n  if (status !== 0) {\n    throw new Error(\"Couldn't install packages\");\n  }\n}\n\nfunction installTetragon({ actionDirectory }: { actionDirectory: string }) {\n  console.log(\"Installing Tetragon\");\n\n  const { status } = spawnSync(\n    \"bash\",\n    [path.join(actionDirectory, \"scripts\", \"install_tetragon.sh\")],\n    {\n      stdio: \"inherit\",\n      env: {\n        TETRAGON_POLICIES_DIRECTORY: path.join(actionDirectory, \"tetragon\"),\n      },\n    }\n  );\n\n  if (status !== 0) {\n    throw new Error(\"Couldn't install Tetragon\");\n  }\n}\n\nasync function startTetragon({\n  connectLogFilepath,\n  tetragonLogFilepath,\n}: {\n  connectLogFilepath: string;\n  tetragonLogFilepath: string;\n}) {\n  const out = (await fs.open(tetragonLogFilepath, \"a\")).fd;\n\n  core.debug(\"Starting Tetragon\");\n  console.time(\"Tetragon startup time\");\n  spawn(\"sudo\", [\"tetragon\"], {\n    stdio: [\"ignore\", out, out],\n    detached: true,\n  }).unref();\n\n  const tetragonReady = await waitForFile(TETRAGON_EVENTS_LOG_PATH);\n  if (!tetragonReady) {\n    throw new Error(\"Tetragon could not start\");\n  }\n  console.timeEnd(\"Tetragon startup time\");\n\n  const connectOut = (await fs.open(connectLogFilepath, \"a\")).fd;\n  spawn(\n    `sudo tail -n +1 -F ${TETRAGON_EVENTS_LOG_PATH} | jq -c --unbuffered 'select(.process_kprobe.policy_name == \"connect\")'`,\n    {\n      shell: true,\n      stdio: [\"ignore\", connectOut, \"ignore\"],\n      detached: true,\n    }\n  ).unref();\n}\n\nasync function downloadAgent({\n  actionDirectory,\n  localAgentPath,\n  version,\n  agentDownloadBaseURL,\n}: {\n  actionDirectory: string;\n  localAgentPath: string;\n  version: string;\n  agentDownloadBaseURL: string;\n}): Promise<string> {\n  if (localAgentPath !== \"\") {\n    const absolutePath = path.join(actionDirectory, \"..\", localAgentPath);\n    core.debug(`Using local agent from ${absolutePath}`);\n    return absolutePath;\n  }\n  console.log(`Downloading agent v${version}`);\n\n  const { status } = spawnSync(\n    \"bash\",\n    [\n      path.join(actionDirectory, \"scripts\", \"download_agent.sh\"),\n      `v${version}`,\n      agentDownloadBaseURL,\n    ],\n    { stdio: \"inherit\" }\n  );\n\n  if (status !== 0) {\n    throw new Error(\"Couldn't download agent\");\n  }\n\n  return AGENT_INSTALL_PATH;\n}\n\nasync function startAgent({\n  agentDirectory,\n  dnsPolicy,\n  egressPolicy,\n  agentLogFilepath,\n  agentPath,\n}: {\n  agentDirectory: string;\n  dnsPolicy: DnsPolicy;\n  egressPolicy: EgressPolicy;\n  agentLogFilepath: string;\n  agentPath: string;\n}) {\n  const blockingMode = egressPolicy === BLOCK;\n\n  console.log(\"Loading nftables rules\");\n\n  if (blockingMode && dnsPolicy === ALLOWED_DOMAINS_ONLY) {\n    await exec(\n      `sudo nft -f ${path.join(agentDirectory, \"queue_block_with_dns.nft\")}`\n    );\n    console.log(\"loaded blocking rules (with DNS)\");\n  } else if (blockingMode) {\n    await exec(`sudo nft -f ${path.join(agentDirectory, \"queue_block.nft\")}`);\n    console.log(\"loaded blocking rules\");\n  } else {\n    await exec(`sudo nft -f ${path.join(agentDirectory, \"queue_audit.nft\")}`);\n    console.log(\"loaded audit rules\");\n  }\n\n  const agentOut = (await fs.open(agentLogFilepath, \"a\")).fd;\n  console.log(`Starting agent from ${agentPath}`);\n  console.time(\"Agent startup time\");\n\n  // make agent executable\n  await exec(`sudo chmod +x ${agentPath}`);\n\n  spawn(\n    \"sudo\",\n    [agentPath, \"--dns-policy\", dnsPolicy, \"--egress-policy\", egressPolicy],\n    {\n      stdio: [\"ignore\", agentOut, agentOut],\n      detached: true,\n    }\n  ).unref();\n\n  const agentReady = await waitForFile(AGENT_READY_PATH);\n  if (!agentReady) {\n    throw new Error(\"Agent could not start\");\n  }\n  console.timeEnd(\"Agent startup time\");\n}\n\nasync function _main() {\n  const {\n    allowedDomains,\n    allowedIps,\n    dnsPolicy,\n    egressPolicy,\n    logDirectory,\n    localAgentPath,\n    agentDownloadBaseURL,\n  } = parseInputs();\n\n  const actionDirectory = path.join(__dirname, \"..\");\n  const agentDirectory = path.join(actionDirectory, \"..\", \"agent\");\n  const pkg = require(`${actionDirectory}/../package.json`);\n\n  await fs.mkdir(logDirectory, { recursive: true });\n\n  if (allowedDomains.length !== 0) {\n    await fs.writeFile(\"allowed_domains.txt\", allowedDomains.join(\"\\n\"));\n  }\n\n  if (allowedIps.length !== 0) {\n    await fs.writeFile(\"allowed_ips.txt\", allowedIps.join(\"\\n\"));\n  }\n\n  const agentLogFilepath = path.join(logDirectory, AGENT_LOG_FILENAME);\n  const connectLogFilepath = path.join(logDirectory, CONNECT_LOG_FILENAME);\n  const tetragonLogFilepath = path.join(logDirectory, TETRAGON_LOG_FILENAME);\n\n  installPackages();\n  installTetragon({ actionDirectory });\n  await startTetragon({\n    connectLogFilepath,\n    tetragonLogFilepath,\n  });\n  const agentPath = await downloadAgent({\n    actionDirectory,\n    localAgentPath,\n    version: pkg.version,\n    agentDownloadBaseURL,\n  });\n  await startAgent({\n    agentDirectory,\n    dnsPolicy,\n    egressPolicy,\n    agentLogFilepath,\n    agentPath,\n  });\n}\n\nasync function main() {\n  try {\n    await _main();\n  } catch (error: any) {\n    console.error(error);\n    core.setFailed(error);\n    process.exit(1);\n  }\n}\n\n// Main has a global try catch, it should never throw\nmain();\n", "export const AGENT_LOG_FILENAME = \"agent.log\";\nexport const CONNECT_LOG_FILENAME = \"connect.log\";\nexport const TETRAGON_LOG_FILENAME = \"tetragon.log\";\nexport const TETRAGON_EVENTS_LOG_PATH = \"/var/log/tetragon/tetragon.log\";\n\nexport const AGENT_INSTALL_PATH = \"/opt/bullfrog/agent\";\nexport const AGENT_READY_PATH = \"/var/run/bullfrog/agent-ready\";\n\nexport const AUDIT = \"audit\";\nexport const BLOCK = \"block\";\n\nexport const ALLOWED_DOMAINS_ONLY = \"allowed-domains-only\";\nexport const ANY = \"any\";\n", "import * as core from \"@actions/core\";\nimport { ALLOWED_DOMAINS_ONLY, ANY, AUDIT, BLOCK } from \"./constants\";\n\nexport type DnsPolicy = typeof ALLOWED_DOMAINS_ONLY | typeof ANY;\nexport type EgressPolicy = typeof AUDIT | typeof BLOCK;\n\nexport interface Inputs {\n  allowedDomains: Array<string>;\n  allowedIps: Array<string>;\n  dnsPolicy: DnsPolicy;\n  egressPolicy: EgressPolicy;\n  logDirectory: string;\n  localAgentPath: string;\n  agentDownloadBaseURL: string;\n}\n\nexport function parseInputs(): Inputs {\n  const rawAllowedIps = core.getInput(\"allowed-ips\");\n\n  const allowedIps =\n    rawAllowedIps.length !== 0 ? rawAllowedIps.split(\"\\n\") : [];\n\n  const rawAllowedDomains = core.getInput(\"allowed-domains\");\n\n  const allowedDomains =\n    rawAllowedDomains.length !== 0 ? rawAllowedDomains.split(\"\\n\") : [];\n\n  const egressPolicy = core.getInput(\"egress-policy\");\n  if (egressPolicy !== AUDIT && egressPolicy !== BLOCK) {\n    throw new Error(`egress-policy must be '${AUDIT}' or '${BLOCK}'`);\n  }\n\n  const dnsPolicy = core.getInput(\"dns-policy\");\n\n  if (dnsPolicy !== ALLOWED_DOMAINS_ONLY && dnsPolicy !== ANY) {\n    throw new Error(`dns-policy must be '${ALLOWED_DOMAINS_ONLY}' or '${ANY}'`);\n  }\n\n  return {\n    allowedDomains,\n    allowedIps,\n    dnsPolicy,\n    egressPolicy,\n    logDirectory: core.getInput(\"log-directory\", { required: true }),\n    localAgentPath: core.getInput(\"local-agent-path\"),\n    agentDownloadBaseURL: core.getInput(\"agent-download-base-url\"),\n  };\n}\n", "import * as core from \"@actions/core\";\nimport fs from \"node:fs/promises\";\nimport { setTimeout } from \"node:timers/promises\";\n\nexport async function waitForFile(\n  filePath: string,\n  timeout = 15000,\n  interval = 500\n) {\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeout) {\n    try {\n      await fs.access(filePath);\n      core.debug(`File ${filePath} is available!`);\n      return true;\n    } catch (err) {\n      // File is not available yet\n      await setTimeout(interval);\n    }\n  }\n\n  core.debug(`Timeout: File ${filePath} is not available.`);\n  return false;\n}\n"],
  "mappings": "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",
  "names": ["core", "import_promises", "core", "import_promises", "fs", "util", "execCb", "path", "fs"]
}
