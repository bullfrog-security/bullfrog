{
  "version": 3,
  "sources": ["../src/post.ts", "../src/inputs.ts", "../src/constants.ts"],
  "sourcesContent": ["import * as core from \"@actions/core\";\nimport fs from \"node:fs/promises\";\nimport util from \"node:util\";\nimport { exec as execCb } from \"node:child_process\";\nimport { parseInputs } from \"./inputs\";\nimport path from \"node:path\";\nimport { AGENT_LOG_FILENAME, BLOCK, CONNECT_LOG_FILENAME } from \"./constants\";\n\nconst exec = util.promisify(execCb);\n\nconst DECISISONS_LOG_PATH = \"/var/log/gha-agent/decisions.log\";\n\nasync function printAnnotations({\n  connectLogFilepath,\n}: {\n  connectLogFilepath: string;\n}) {\n  try {\n    const correlatedData = await getCorrelateData({ connectLogFilepath });\n    const { egressPolicy } = parseInputs();\n    const result = egressPolicy === BLOCK ? \"Blocked\" : \"Unauthorized\";\n\n    core.debug(\"\\n\\nCorrelated data:\\n\");\n\n    const annotations: string[] = [];\n\n    correlatedData.forEach((data) => {\n      core.debug(JSON.stringify(data));\n      if (data.decision !== \"blocked\") {\n        return;\n      }\n      const time = data.ts.toISOString();\n      if (data.domain === \"unknown\") {\n        annotations.push(\n          `[${time}] ${result} request to ${data.destIp}:${data.destPort} from processs \\`${data.binary} ${data.args}\\``\n        );\n        return;\n      } else if (data.destIp === \"unknown\") {\n        annotations.push(\n          `[${time}] ${result} DNS request to ${data.domain} from unknown process`\n        );\n      } else {\n        annotations.push(\n          `[${time}] ${result} request to ${data.domain} (${data.destIp}:${data.destPort}) from process \\`${data.binary} ${data.args}\\``\n        );\n      }\n    });\n    core.warning(annotations.join(\"\\n\"));\n    return;\n  } catch (error) {\n    core.debug(\"No annotations found\");\n  }\n}\n\ntype TetragonLog = {\n  ts: Date;\n  destIp: string;\n  destPort: string;\n  binary: string;\n  args: string;\n};\n\ntype Decision = {\n  ts: Date;\n  decision: \"allowed\" | \"blocked\";\n  domain: string;\n  destIp: string;\n};\n\ntype CorrelatedData = TetragonLog & Decision;\n\nasync function getOutboundConnections({\n  connectLogFilepath,\n}: {\n  connectLogFilepath: string;\n}): Promise<TetragonLog[]> {\n  try {\n    const connections: TetragonLog[] = [];\n    // TODO: We shouldn't be using sudo at this point, since we'll probably want to disable sudo early in the action\n    await exec(`sudo chmod 644 ${connectLogFilepath}`);\n    const log = await fs.readFile(connectLogFilepath, \"utf8\");\n    const lines = log.split(\"\\n\");\n    const functionsToTrack = [\"tcp_connect\"];\n    for (const line of lines) {\n      if (!line) continue;\n      const processEntry = JSON.parse(line).process_kprobe;\n      if (!processEntry) continue;\n      if (functionsToTrack.includes(processEntry.function_name)) {\n        connections.push({\n          ts: new Date(processEntry.process.start_time),\n          destIp: processEntry.args[0].sock_arg.daddr,\n          destPort: processEntry.args[0].sock_arg.dport,\n          binary: processEntry.process.binary,\n          args: processEntry.process.arguments,\n        });\n      }\n    }\n    return connections;\n  } catch (error) {\n    console.error(\"Error reading log file\", error);\n    return [];\n  }\n}\n\nasync function getDecisions(): Promise<Decision[]> {\n  try {\n    const decisions: Decision[] = [];\n    const log = await fs.readFile(DECISISONS_LOG_PATH, \"utf8\");\n    const lines = log.split(\"\\n\");\n    for (const line of lines) {\n      const values = line.split(\"|\");\n      decisions.push({\n        ts: new Date(parseInt(values[0]) * 1000),\n        decision: values[1] as \"allowed\" | \"blocked\",\n        domain: values[2],\n        destIp: values[3],\n      });\n    }\n    return decisions;\n  } catch (error) {\n    console.error(\"Error reading log file\", error);\n    return [];\n  }\n}\n\nasync function getCorrelateData({\n  connectLogFilepath,\n}: {\n  connectLogFilepath: string;\n}): Promise<CorrelatedData[]> {\n  // give some time for the logs to be written\n  await new Promise((resolve) => setTimeout(resolve, 5000));\n\n  const connections = await getOutboundConnections({ connectLogFilepath });\n  core.debug(\"\\n\\nConnections:\\n\");\n  connections.forEach((c) => core.debug(JSON.stringify(c)));\n\n  const decisions = await getDecisions();\n  core.debug(\"\\nDecisions:\\n\");\n  decisions.forEach((d) => core.debug(JSON.stringify(d)));\n  const correlatedData: CorrelatedData[] = [];\n  for (const connection of connections) {\n    let decision = decisions.find(\n      (d) => connection.destIp === d.destIp && d.domain !== \"unknown\"\n    );\n    if (!decision) {\n      decision = decisions.find((d) => connection.destIp === d.destIp);\n    }\n    correlatedData.push({\n      ts: connection.ts,\n      decision: decision?.decision ?? \"blocked\", // if we don't have a decision, assume it's blocked because we use an allowlist\n      domain: decision?.domain ?? \"unknown\",\n      destIp: connection.destIp,\n      destPort: connection.destPort,\n      binary: connection.binary,\n      args: connection.args,\n    });\n  }\n  // Add any decisions that don't have a corresponding connection (blocked DNS queries)\n  for (const decision of decisions.filter((d) => d.destIp === \"unknown\")) {\n    correlatedData.push({\n      ts: decision.ts,\n      decision: decision.decision,\n      domain: decision.domain,\n      destIp: \"unknown\",\n      destPort: \"unknown\",\n      binary: \"unknown\",\n      args: \"unknown\",\n    });\n  }\n  return correlatedData;\n}\n\nasync function printAgentLogs({\n  agentLogFilepath,\n}: {\n  agentLogFilepath: string;\n}) {\n  try {\n    const log = await fs.readFile(agentLogFilepath, \"utf8\");\n    const lines = log.split(\"\\n\");\n    for (const line of lines) {\n      core.debug(line);\n    }\n  } catch (error) {\n    console.error(\"Error reading log file\", error);\n  }\n}\n\nasync function _main() {\n  const { logDirectory } = parseInputs();\n  const connectLogFilepath = path.join(logDirectory, CONNECT_LOG_FILENAME);\n  const agentLogFilepath = path.join(logDirectory, AGENT_LOG_FILENAME);\n\n  await printAnnotations({ connectLogFilepath });\n  await printAgentLogs({ agentLogFilepath });\n}\n\nasync function main() {\n  try {\n    await _main();\n  } catch (error: any) {\n    console.error(error);\n    core.setFailed(error);\n    process.exit(1);\n  }\n}\n\n// Main has a global try catch, it should never throw\nmain();\n", "import * as core from \"@actions/core\";\nimport { ALLOWED_DOMAINS_ONLY, ANY, AUDIT, BLOCK } from \"./constants\";\n\nexport type DnsPolicy = typeof ALLOWED_DOMAINS_ONLY | typeof ANY;\nexport type EgressPolicy = typeof AUDIT | typeof BLOCK;\n\nexport interface Inputs {\n  allowedDomains: Array<string>;\n  allowedIps: Array<string>;\n  dnsPolicy: DnsPolicy;\n  egressPolicy: EgressPolicy;\n  logDirectory: string;\n  localAgentPath: string;\n  agentDownloadBaseURL: string;\n}\n\nexport function parseInputs(): Inputs {\n  const rawAllowedIps = core.getInput(\"allowed-ips\");\n\n  const allowedIps =\n    rawAllowedIps.length !== 0 ? rawAllowedIps.split(\"\\n\") : [];\n\n  const rawAllowedDomains = core.getInput(\"allowed-domains\");\n\n  const allowedDomains =\n    rawAllowedDomains.length !== 0 ? rawAllowedDomains.split(\"\\n\") : [];\n\n  const egressPolicy = core.getInput(\"egress-policy\");\n  if (egressPolicy !== AUDIT && egressPolicy !== BLOCK) {\n    throw new Error(`egress-policy must be '${AUDIT}' or '${BLOCK}'`);\n  }\n\n  const dnsPolicy = core.getInput(\"dns-policy\");\n\n  if (dnsPolicy !== ALLOWED_DOMAINS_ONLY && dnsPolicy !== ANY) {\n    throw new Error(`dns-policy must be '${ALLOWED_DOMAINS_ONLY}' or '${ANY}'`);\n  }\n\n  return {\n    allowedDomains,\n    allowedIps,\n    dnsPolicy,\n    egressPolicy,\n    logDirectory: core.getInput(\"log-directory\", { required: true }),\n    localAgentPath: core.getInput(\"local-agent-path\"),\n    agentDownloadBaseURL: core.getInput(\"agent-download-base-url\"),\n  };\n}\n", "export const AGENT_LOG_FILENAME = \"agent.log\";\nexport const CONNECT_LOG_FILENAME = \"connect.log\";\nexport const TETRAGON_LOG_FILENAME = \"tetragon.log\";\nexport const TETRAGON_EVENTS_LOG_PATH = \"/var/log/tetragon/tetragon.log\";\n\nexport const AGENT_INSTALL_PATH = \"/opt/bullfrog/agent\";\nexport const AGENT_READY_PATH = \"/var/run/bullfrog/agent-ready\";\n\nexport const AUDIT = \"audit\";\nexport const BLOCK = \"block\";\n\nexport const ALLOWED_DOMAINS_ONLY = \"allowed-domains-only\";\nexport const ANY = \"any\";\n"],
  "mappings": "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",
  "names": ["core", "util", "execCb", "fs", "path"]
}
